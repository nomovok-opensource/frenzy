/* 
 * Copyright 2013 by Nomovok Ltd.
 * 
 * Contact: info@nomovok.com
 * 
 * This Source Code Form is subject to the
 * terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with
 * this file, You can obtain one at
 * http://mozilla.org/MPL/2.0/.
 * 
 */

#ifndef FRENZY_TEST_HELPERS_HPP
#define FRENZY_TEST_HELPERS_HPP

#define BOOST_TEST_DYN_LINK
#include <boost/test/unit_test.hpp>

#include <string>
#include <algorithm>
#include <ostream>
#include <iterator>
#include <vector>
#include <set>
#include <map>

#include <boost/optional.hpp>

#include "util/unicode.hpp"
#include "util/vector.hpp"
#include "dom/node.hpp"
#include "dom/pointers.hpp"
#include "parser/chardecoder.hpp" // for bytestring. TODO: Move it somewhere else.

namespace frenzy
{
  namespace test_helpers
  {
    // Helper for converting a std::string to bytestring
    inline bytestring bstr(std::string in)
    {
      return bytestring(in.begin(), in.end());
    }

    // Helper for converting a std::string to ustring, converting all
    // values 'from' to value 'to'
    inline ustring ustr(std::string in, uchar from, uchar to)
    {
      ustring ret(in);
      std::replace(ret.begin(), ret.end(), from, to);
      return ret;
    }

    // Helper for converting a std::string to ustring, converting all
    // values 'from' to value 'to', and all values 'from2' to value
    // 'to2'
    inline ustring ustr(std::string in, uchar from, uchar to,
                                  uchar from2, uchar to2)
    {
      ustring ret(in);
      std::replace(ret.begin(), ret.end(), from, to);
      std::replace(ret.begin(), ret.end(), from2, to2);
      return ret;
    }
    
    // Helper for destination attachment for uropes
    struct destination
    {
      destination()
	: ended(false)
      {
      }

      void receive(const urope& input)
      {
	items.append(input);
	if (input.empty())
	  ended = true;
      }
      
      urope items;
      bool ended;
    };

    // Helper for destination attachment for single items
    template <typename T>
    struct destinationT
    {
      void receive(const T& input)
      {
	items.push_back(input);
      }

      std::vector<T> items;
    };

    // Load a document from a file. Used by w3domts autogenerated tests.
    dom::Documentp load(std::string filename);

    bool ascii_case_insensitive_equals(ustring one, ustring two);

    template <typename T>
    bool ascii_case_insensitive_equals(const T& one, const T& two)
    {
      if (one.size() != two.size())
	return false;

      for (typename T::const_iterator oneit = one.begin(), twoit = two.begin();
	   oneit != one.end();
	   ++oneit, ++twoit)
      {
	if (!ascii_case_insensitive_equals(*oneit, *twoit))
	  return false;
      }
      
      return true;
    }

    std::vector<ustring> ascii_toupper(const std::vector<ustring>& v);

    template <typename T>
    T deref_if_optional(T t)
    {
      return t;
    }

    template <typename T>
    T deref_if_optional(boost::optional<T> t)
    {
      BOOST_REQUIRE(t.is_initialized());
      return *t;
    }

    inline size_t size(dom::NodeListp nl)
    {
      return nl->get_length();
    }

    template <typename T>
    size_t size(const T& t)
    {
      return t.size();
    }

    template <typename T>
    T convert(T t)
    {
      return t;
    }

    template <typename T, typename U>
    T convert(boost::shared_ptr<U> u)
    {
      if (!u)
	return T();

      T ret = dom_cast<typename T::value_type>(u);
      BOOST_REQUIRE_MESSAGE(ret, "Node cast failed, type is " << u->get_nodeType());
      return ret;
    }

    // Returns the given string as ustring, with utf8 decoding
    ustring utf8dec(std::string str);
    inline ustring utf8dec(const char* str)
    {
      return utf8dec(std::string(str));
    }

    // For other types, just returns the value as is
    template <typename T>
    T utf8dec(T t)
    {
      return t;
    }

    /*
     * Mockup dom elements for comparison to real tree construction
     * results.
     *
     * With operator overloading that's not suitable for any real world
     * use, you can express an element tree like so:
     *
     * elem("name")                 -   single element
     * elem("foo") + elem("bar")    -   bar is a child of foo
     *
     * Grouping with parentheses lets you express trees of elements:
     *
     * elem("html")
     * + (elem("head")
     *    + elem("title"))
     * + (elem("body")
     *    + elem("p"));
     *
     * Note that operator+ is left associative so this
     *
     *  elem("foo") + elem("bar") + elem("quz")
     *
     * means foo has two children, bar and quz, not that quz is a child
     * of bar.
     *
     * With 'attr' attributes can be represented. Attributes can be
     * combined with operator+ like the above mock elements. Example:
     *
     * elem("p", attr("class", "x") + attr("style", "color: black"))
     */
    struct mocknode
    {
      mocknode(dom::Node::nodeType type);
      
      dom::Node::nodeType type;
      std::string name;
      
      std::vector<mocknode> children;
      std::map<std::string, std::string> attributes;
    };
    
    struct attr
    {
      attr();
      
      attr(std::string key, std::string value);
      
      std::map<std::string, std::string> attributes;
    };
    
    mocknode operator+(mocknode one, mocknode two);
    attr operator+(attr one, attr two);

    mocknode elem(std::string name, attr attributes = attr());
    mocknode txt(std::string text);
    
    void assert_node_and_children(dom::Nodep n, mocknode expected, size_t depth = 0);
  }
  
  // Printing for boost.test macros
  inline std::ostream& operator<<(std::ostream& out, const urope& data)
  {
    out << "[size " << data.size() << "]";
    std::copy(data.begin(), data.end(), std::ostream_iterator<char>(out, ""));
    return out;
  }

  inline std::ostream& operator<<(std::ostream& out, const ustring& data)
  {
    out << "[size " << data.size() << "]";
    std::copy(data.begin(), data.end(), std::ostream_iterator<char>(out, ""));
    return out;
  }

  inline std::ostream& operator<<(std::ostream& out, const std::vector<ustring>& data)
  {
    out << "[size " << data.size() << "]";
    std::copy(data.begin(), data.end(), std::ostream_iterator<ustring>(out, ""));
    return out;
  }

  inline std::ostream& operator<<(std::ostream& out, const std::set<ustring>& data)
  {
    out << "[size " << data.size() << "]";
    std::copy(data.begin(), data.end(), std::ostream_iterator<ustring>(out, ""));
    return out;
  }

  inline std::ostream& operator<<(std::ostream& out, const vec& v)
  {
    return out << "[" << v.n << "]";
  }

  inline std::ostream& operator<<(std::ostream& out, const vec2& v)
  {
    return out << "[" << v.x.n << ", " << v.y.n << "]";
  }
}

#endif
