/* 
 * Copyright 2013 by Nomovok Ltd.
 * 
 * Contact: info@nomovok.com
 * 
 * This Source Code Form is subject to the
 * terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with
 * this file, You can obtain one at
 * http://mozilla.org/MPL/2.0/.
 * 
 */

#include <string>
#include <iostream>
#include <fstream>
#include <map>
#include <cstdlib>

// This program parses an entities.json file as it is attached to the
// HTML5 specification. The url is
// http://www.w3.org/TR/html5/entities.json .  Output is C++
// applicable to be used as htmlentitydb.cpp.

// Ugly and ad hoc code below. Be warned.

std::string read_name(std::istream& input)
{
  std::string name;
  char quote;
  input >> quote;
  if (quote != '"')
  {
    // Unquoted name? Weird, but fine
    // Note that this code path will be untested
    std::getline(input, name, ':');
    name.insert(name.begin(), quote);
    // Trim whitespace
    while (!name.empty() && (name[name.size() - 1] == ' ' || name[name.size() - 1] == '\t'))
    {
      name.resize(name.size() - 1);
    }
    while (!name.empty() && (name[0] == ' ' || name[0] == '\t'))
    {
      name.erase(name.begin());
    }
  }
  else
  {
    std::getline(input, name, '"');
  }
  
  return name;
}

// Read a character, exit(1) if it's not c
void expect(std::istream& input, char c)
{
  char dummy;
  input >> dummy;
  if (dummy != c)
  {
    std::cerr << "Format error: Expected " << c << '\n';
    std::exit(1);
  }
}

// Read a name, exit(1) if it's not str
void expect(std::istream& input, std::string str)
{
  std::string name = read_name(input);
  if (name != str)
  {
    std::cerr << "Format error: Expected '" << str << "'\n";
    std::exit(1);
  }
}

std::string varname(std::string name)
{
  std::string ret;
  for (size_t i = 0; i < name.size(); ++i)
  {
    if (name[i] == ';')
      ret += "sc";
    else
      ret += name[i];
  }

  ret += "_name";

  return ret;
}

void print_names(std::ostream& output, const std::map<std::string, std::pair<int, int> >& ents)
{
  for (std::map<std::string, std::pair<int, int> >::const_iterator it = ents.begin();
       it != ents.end();
       ++it)
  {
    std::string name = it->first;
    output << "  const frenzy::uchar " << varname(name) << "[] = { ";
    for (size_t i = 0; i < name.size(); ++i)
    {
      if (i)
        output << ", ";
      output << "'" << name[i] << "'";
    }
    output << " };\n";
  }
}

int main(int argc, char** argv)
{
  if (argc != 3)
  {
    std::cerr << "Usage: " << argv[0] << " inputfile outputfile\n";
    return 1;
  }

  std::ifstream input(argv[1]);
  if (!input || !input.is_open())
  {
    std::cerr << "Cannot open input file: " << argv[1] << '\n';
    return 1;
  }

  std::map<std::string, std::pair<int, int> > ents;

  // Read out the leading opening brace
  expect(input, '{');

  while (input)
  {
    std::string name = read_name(input);
    expect(input, ':');
    expect(input, '{');
    expect(input, "codepoints");
    expect(input, ':');
    expect(input, '[');
    
    size_t cp1 = 0;
    size_t cp2 = 0;
    
    input >> cp1;
    
    char dummy;
    input >> dummy;
    if (dummy == ',')
    {
      input >> cp2;
      input >> dummy;
    }

    if (dummy != ']')
    {
      std::cerr << "Format error: Closing bracket not found\n";
      return 1;
    }

    expect(input, ',');
    expect(input, "characters");
    expect(input, ':');
    read_name(input);
    expect(input, '}');
    
    // Discard &
    if (name[0] != '&')
    {
      std::cerr << "Format error: Name doesn't begin with ampersand\n";
      return 1;
    }
    name.erase(name.begin());
    ents.insert(std::make_pair(name, std::make_pair(cp1, cp2)));

    input >> dummy;
    if (dummy == '}')
    {
      break;
    }
    if (dummy != ',')
    {
      std::cerr << "Format error: Comma expected\n";
      return 1;
    }
  }

  std::ofstream output(argv[2]);
  if (!output || !output.is_open())
  {
    std::cerr << "Cannot open output file: " << argv[2] << '\n';
    return 1;
  }
  
  output <<
    "/* This file is automatically generated. Do not edit! */\n"
    "#include \"parser/htmlentitydb.hpp\"\n\n"
    "namespace\n"
    "{\n";

  print_names(output, ents);

  output << "\n  const frenzy::parser::htmlentity entities[" << ents.size() << "] = {";

  size_t offset = 0;
  std::map<char, size_t> offsetmapping;
  char lastchar = 0;
  for (std::map<std::string, std::pair<int, int> >::const_iterator it = ents.begin();
       it != ents.end();
       ++it)
  {
    if (it != ents.begin())
      output << ",";
    output << "\n";

    std::string name = it->first;
    int cp1 = it->second.first;
    int cp2 = it->second.second;

    if (lastchar != name[0])
    {
      lastchar = name[0];
      offsetmapping[lastchar] = offset;
    }

    ++offset;
    output << "    { " << varname(name) << ", " << name.size() << ", " << cp1 << ", " << cp2 << " }";
  }
  output << "\n  };\n";

  output << "\n  const frenzy::parser::htmlentity* uppercases[] = {";
  for (char x = 'A'; x <= 'Z'; ++x)
  {
    if (x != 'A')
      output << ",";
    output << "\n";

    std::map<char, size_t>::const_iterator off = offsetmapping.find(x);
    if (off == offsetmapping.end())
    {
      std::cerr << "Fatal, no offset available for " << x << '\n';
      return 1;
    }
    output << "    &entities[" << off->second << "]";
  }
  // One more
  output << ",\n    &entities[" << offsetmapping['a'] << "]\n  };\n";

  output << "\n  const frenzy::parser::htmlentity* lowercases[] = {";
  for (char x = 'a'; x <= 'z'; ++x)
  {
    if (x != 'a')
      output << ",";
    output << "\n";

    std::map<char, size_t>::const_iterator off = offsetmapping.find(x);
    if (off == offsetmapping.end())
    {
      std::cerr << "Fatal, no offset available for " << x << '\n';
      return 1;
    }
    output << "    &entities[" << off->second << "]";
  }
  // One more
  output << ",\n    &entities[" << ents.size() << "]\n  };\n";

  output << "}\n\n";

  output << "const frenzy::parser::htmlentity*\n"
    "frenzy::parser::htmlentity_begin(frenzy::uchar u)\n"
    "{\n"
    "  if (u >= 'a' && u <= 'z')\n"
    "    return lowercases[u - 'a'];\n"
    "  else if (u >= 'A' && u <= 'Z')\n"
    "    return uppercases[u - 'A'];\n"
    "  return NULL;\n"
    "}\n\n"
    "const frenzy::parser::htmlentity*\n"
    "frenzy::parser::htmlentity_end(frenzy::uchar u)\n"
    "{\n"
    "  if (u >= 'a' && u <= 'z')\n"
    "    return lowercases[u - 'a' + 1] - 1;\n"
    "  else if (u >= 'A' && u <= 'Z')\n"
    "    return uppercases[u - 'A' + 1] - 1;\n"
    "  return NULL;\n"
    "}\n";
}
